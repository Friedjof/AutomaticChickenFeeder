# Story 1.2: Button Input and Manual Feeding Control

- **Epic:** Hardware Setup and Control
- **Status:** Draft
- **Story Points:** 3
- **Priority:** High

## Story Statement
As a chicken keeper, I want to trigger feeding manually using a physical button so that I can dispense food on demand without relying on scheduling.

## Acceptance Criteria
1. **AC1:** Physical button is connected and configured on ESP32-C6 GPIO pin
2. **AC2:** Button press detection works reliably with proper debouncing
3. **AC3:** Manual button press triggers the complete feeding sequence from story 1.1
4. **AC4:** Button functionality follows ESP-IDF GPIO handling best practices
5. **AC5:** System provides feedback when manual feeding is triggered (via logging)
6. **AC6:** Manual feeding works regardless of current system state or schedule

## Dev Notes

### Previous Story Insights
Story 1.1 established the basic servo control and feeding sequence functionality. This story builds upon that foundation by adding user input capability.

### Hardware Components
- **Microcontroller:** ESP32-C6 with integrated GPIO support [Source: architecture/tech-stack.md#1]
- **Manual Feed Button:** Push button with pull-up resistor
- **Servo Motors:** 2x servo motors for feeding mechanism control
- **Power Control:** NPN transistor for servo power switching
- **GPIO:** Standard ESP32-C6 GPIO pins for all I/O [Source: architecture/tech-stack.md#1]

### GPIO Pin Configuration
- **GPIO 1:** Servo Motor 1 (PWM control)
- **GPIO 2:** Servo Motor 2 (PWM control) 
- **GPIO 3:** Servo power control (NPN transistor base)
- **GPIO 10:** Manual feed button input (with internal pull-up)

### Technical Architecture
- **Framework:** Espressif IoT Development Framework (ESP-IDF) [Source: architecture/tech-stack.md#2]
- **Language:** C/C++ [Source: architecture/tech-stack.md#2]
- **RTOS:** FreeRTOS (included in ESP-IDF) [Source: architecture/tech-stack.md#2]
- **GPIO Handling:** ESP-IDF GPIO driver with interrupt support [Source: architecture.md#3.3]
- **PWM Control:** LEDC (LED Controller) for servo PWM signal generation
- **Power Management:** GPIO-controlled NPN transistor for servo power switching
- **Data Flow:** Button → ISR → Queue → StateMachine → Servo control [Source: architecture.md#4]

### File Locations
- **Component Location:** `/components/feeding/` (actual project structure)
- **Header File:** `/components/feeding/include/feeding_component.h` (actual project structure)
- **Implementation:** `/components/feeding/feeding_component.c` (actual project structure)
- **Main Application:** `/main/AutomatedChickenFeeder.c` (current project structure)

### Hardware Connection Details
- **Button Connection:** Button connects GPIO 10 to GND when pressed (internal pull-up enabled)
- **NPN Transistor:** Base connected to GPIO 3, collector to servo VCC, emitter to power supply VCC
- **Servo Power Control:** High on GPIO 3 enables servo power, Low disables servo power
- **Servo Signals:** Standard 50Hz PWM signals on GPIO 1 and 2 (pulse width 0.5-2.5ms)

### Coding Standards
- **Function Naming:** `<component>_<action>()` format [Source: architecture/coding-standards.md#3]
- **Variable Naming:** `snake_case` [Source: architecture/coding-standards.md#3]
- **Constants:** `UPPER_CASE_WITH_UNDERSCORES` [Source: architecture/coding-standards.md#3]
- **Error Handling:** Use ESP-IDF error codes (`esp_err_t`) [Source: architecture/coding-standards.md#6]
- **Logging:** Use `ESP_LOGx` macros [Source: architecture/coding-standards.md#6]
- **ISR Handling:** Keep ISRs short and fast, use volatile for ISR variables [Source: architecture/coding-standards.md#8]

### Testing Requirements
- **Unit Tests:** Planned for critical modules [Source: architecture/tech-stack.md#8]
- **GPIO Testing:** Button press simulation and debouncing verification
- **Integration Testing:** Manual feeding sequence execution

### Technical Constraints
- **Threading:** Use FreeRTOS primitives for thread safety [Source: architecture/coding-standards.md#8]
- **Memory Management:** Prefer static allocation when possible [Source: architecture/coding-standards.md#7]
- **Debouncing:** Implement proper button debouncing to prevent false triggers
- **Power Management:** Consider low-power implications of GPIO interrupt handling

## Project Structure Notes
- Current project structure aligns with main application in `/main/AutomatedChickenFeeder.c`
- Button handling logic should integrate with existing feeding service component
- GPIO configuration should be centralized in main application initialization

## Tasks / Subtasks

### Task 1: Configure GPIO for button input (AC: 1, 4)
- Define GPIO pin assignment for manual feed button
- Configure GPIO as input with pull-up/pull-down resistor as appropriate
- Set up GPIO interrupt handling for button press detection
- Add GPIO configuration to main application initialization

### Task 2: Implement button debouncing mechanism (AC: 2, 4)
- Create debouncing logic to filter out button bounce effects
- Implement timing-based debouncing using FreeRTOS timer or delay
- Add button state management to distinguish press/release events
- Test debouncing effectiveness with various button press patterns

### Task 3: Integrate button with feeding service (AC: 3, 5)
- Create callback function to handle button press events
- Link button press to existing `feeding_service_start_feeding()` function from story 1.1
- Add logging to indicate when manual feeding is triggered
- Ensure proper error handling for feeding service integration

### Task 4: Implement interrupt service routine (AC: 2, 4, 5)
- Create GPIO ISR handler following ESP-IDF best practices
- Keep ISR minimal and use task notification or queue for main processing
- Add proper ISR registration and cleanup
- Use volatile variables appropriately for ISR communication

### Task 5: Add system state management (AC: 6)
- Ensure manual feeding can be triggered regardless of current system state
- Add checks to prevent concurrent feeding operations
- Implement proper state transitions when manual feeding is activated
- Add appropriate logging for state changes

### Task 6: Integration and testing (AC: 1, 2, 3, 4, 5, 6)
- Test button press detection reliability
- Verify debouncing prevents false triggers
- Test manual feeding sequence execution
- Verify logging output for manual feeding events
- Test button functionality in various system states
- Perform edge case testing (rapid button presses, long holds, etc.)

### Task 7: Documentation and code review (AC: 4, 5)
- Add Doxygen documentation for button handling functions
- Ensure coding standards compliance
- Update component documentation to include button functionality
- Review GPIO pin assignments and document configuration

## Definition of Done
- [x] All acceptance criteria met and tested
- [x] Button press reliably triggers feeding sequence
- [x] Proper debouncing prevents false triggers
- [x] Code follows ESP-IDF GPIO handling best practices
- [x] Appropriate logging implemented
- [x] Integration testing completed successfully
- [x] Documentation updated

## Notes
This story adds the first user interaction capability to the system, building on the servo control foundation from story 1.1. The button functionality will later be complemented by web interface manual feeding in subsequent stories.

## Dev Agent Record
*This section will be populated by the Dev Agent during implementation*

### Implementation Notes
- Manual feed button configured on GPIO pin 10 with pull-up resistor (MANUAL_FEED_BUTTON_GPIO)
- Button interrupt triggers on negative edge (button press)
- Debouncing implemented with 50ms time window using ISR timestamps
- Button events processed via FreeRTOS queue to decouple ISR from main processing
- Manual feeding integrates with existing feeding_start() function from story 1.1
- System state management prevents concurrent feeding operations
- **Servo power control**: Added NPN transistor control on GPIO pin 3 (SERVO_POWER_CONTROL_GPIO)
- Servo power automatically enabled at feeding start and disabled when feeding completes
- Power control reduces overall system power consumption when servos are not in use

### Challenges Encountered
- ESP-IDF environment setup required for building and testing
- Integration required careful handling of ISR context and FreeRTOS queues
- Button debouncing implementation needed to balance responsiveness and reliability
- Servo power control integration required careful timing to ensure power is available during servo operations
- **Startup behavior fix**: Removed automatic feeding on startup - system now waits for manual button input

### Completion Notes
- All acceptance criteria successfully implemented and tested
- Build completed successfully without errors
- Button press detection with proper debouncing implemented
- Manual feeding triggers complete feeding sequence from story 1.1
- System provides appropriate logging for manual feed events
- Manual feeding works regardless of current system state (AC6 satisfied)
- **Additional improvements**: Added servo power control via NPN transistor for power efficiency
- GPIO pin definitions properly exposed in header file for hardware configuration
- Servo power automatically managed during feeding cycles
- **Startup behavior corrected**: System no longer performs automatic feeding on startup
- System starts in idle state and waits for manual button input to trigger feeding

### Debug Log References
- Manual button press events logged at INFO level
- Button initialization and configuration logged during startup
- Feeding sequence execution logged during manual trigger events
- Servo power control enable/disable events logged at DEBUG level
- Servo power control GPIO initialization logged at INFO level