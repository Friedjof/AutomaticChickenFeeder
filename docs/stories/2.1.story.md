# Story 2.1: Basic Scheduling System

- **Epic:** Scheduling and Automation
- **Status:** Draft
- **Story Points:** 8
- **Priority:** High

## Story Statement
As a chicken keeper, I want to set daily feeding times so that the system automatically dispenses food at scheduled intervals without manual intervention.

## Acceptance Criteria
1. **AC1:** System can store and manage multiple daily feeding schedules
2. **AC2:** Each schedule entry includes time (hour:minute) and feeding duration
3. **AC3:** Scheduled feeding automatically triggers the feeding sequence from story 1.1
4. **AC4:** System maintains accurate timekeeping using ESP32-C6 internal RTC
5. **AC5:** Schedules persist across system reboots using non-volatile storage
6. **AC6:** System handles schedule conflicts and edge cases gracefully
7. **AC7:** Scheduled feeding accuracy is within ±10 seconds as per PRD requirements
8. **AC8:** Manual feeding (story 1.2) can override scheduled operations

## Dev Notes

### Previous Story Insights
- Story 1.1 established servo control and feeding sequence functionality
- Story 1.2 added manual button control for on-demand feeding
- Story 1.3 added sensor monitoring (though still in draft)
- This story introduces time-based automation as the first major application layer feature

### Data Models
- **Schedule Entry Structure:** Time-based feeding schedule with hour, minute, duration, and enabled status
- **JSON Configuration:** Feeding schedules stored as JSON for persistence [Source: architecture/tech-stack.md#5]
- No specific guidance found in architecture docs for detailed schedule data schemas

### Technical Architecture
- **Framework:** Espressif IoT Development Framework (ESP-IDF) [Source: architecture/tech-stack.md#2]
- **Language:** C/C++ [Source: architecture/tech-stack.md#2]
- **RTOS:** FreeRTOS for scheduler task management [Source: architecture/tech-stack.md#2]
- **Application Layer:** Feeding Scheduler component [Source: architecture.md#3.1]
- **Data Flow:** Scheduler → StateMachine → Servo control [Source: architecture.md#4]

### File Locations
- **Main Application:** `/main/AutomatedChickenFeeder.c` (current project structure)
- **Scheduler Component:** Create new component following pattern `/components/scheduler_service/`
- **Configuration Storage:** JSON files using LittleFS or NVS [Source: architecture/tech-stack.md#5]
- **Documentation:** `/docs/software/scheduler_service.md` following pattern

### Persistent Storage
- **JSON Configuration Files:** Stores feeding schedules, feed amounts, and named routines [Source: architecture/tech-stack.md#5]
- **Storage Options:** LittleFS (preferred for file-like access) or NVS (for simple key/value pairs) [Source: architecture/tech-stack.md#5]

### Coding Standards
- **Function Naming:** `scheduler_service_<action>()` format [Source: architecture/coding-standards.md#3]
- **Variable Naming:** `snake_case` [Source: architecture/coding-standards.md#3]
- **Constants:** `UPPER_CASE_WITH_UNDERSCORES` [Source: architecture/coding-standards.md#3]
- **Error Handling:** Use ESP-IDF error codes (`esp_err_t`) [Source: architecture/coding-standards.md#6]
- **Logging:** Use `ESP_LOGx` macros [Source: architecture/coding-standards.md#6]
- **Documentation:** Doxygen-style comments for public functions [Source: architecture/coding-standards.md#4]

### Testing Requirements
- **Unit Tests:** Planned for critical modules [Source: architecture/tech-stack.md#8]
- **Schedule Accuracy:** ±10 seconds timing precision validation [Source: PRD section 6]
- **Persistence Testing:** Configuration survival across reboots
- **Integration Testing:** Coordination with feeding service

### Technical Constraints
- **Timing Accuracy:** ±10 seconds precision requirement [Source: PRD section 6]
- **Memory Management:** Prefer static allocation for schedule data [Source: architecture/coding-standards.md#7]
- **Threading:** Use FreeRTOS primitives for scheduler synchronization [Source: architecture/coding-standards.md#8]
- **RTC Management:** ESP32-C6 internal RTC for timekeeping [Source: architecture/tech-stack.md#1]
- **Storage Limitations:** Efficient JSON configuration file management

## Project Structure Notes
- New scheduler_service component should follow established component pattern
- Integration with existing feeding_service for coordinated feeding operations
- Persistent storage integration requires careful file system management
- Consider future web interface requirements for schedule configuration

## Tasks / Subtasks

### Task 1: Set up scheduler service component structure (AC: 1, 5)
- Create `/components/scheduler_service/` directory structure
- Set up CMakeLists.txt with necessary dependencies (LittleFS, JSON parsing)
- Create include and src directories with proper header structure
- Follow coding standards for component organization

### Task 2: Implement schedule data structures (AC: 1, 2)
- Define schedule entry structure with time, duration, enabled status
- Create schedule management functions (add, remove, update, list)
- Implement schedule validation and conflict detection
- Add bounds checking for time values and duration limits

### Task 3: Implement persistent storage for schedules (AC: 5)
- Set up LittleFS or NVS for configuration storage
- Implement JSON serialization/deserialization for schedules
- Create save/load functions for schedule persistence
- Add error handling for storage operations and corruption recovery

### Task 4: Implement RTC and timekeeping (AC: 4, 7)
- Configure ESP32-C6 internal RTC for accurate timekeeping
- Implement time comparison functions for schedule matching
- Add time synchronization mechanisms (prepare for future NTP)
- Create timing precision validation within ±10 seconds requirement

### Task 5: Implement scheduler engine (AC: 3, 6, 7)
- Create FreeRTOS task for continuous schedule monitoring
- Implement schedule evaluation and trigger logic
- Add schedule conflict resolution and edge case handling
- Integrate with feeding_service_start_feeding() from story 1.1

### Task 6: Implement manual override capability (AC: 8)
- Add mechanisms to temporarily disable scheduled feeding
- Ensure manual feeding (button/future web) takes precedence
- Implement schedule resume after manual operations
- Add logging for override events and schedule interactions

### Task 7: Integration and testing (AC: 1, 2, 3, 4, 5, 6, 7, 8)
- Test schedule creation, modification, and deletion
- Verify schedule persistence across system reboots
- Test scheduled feeding trigger accuracy (±10 seconds)
- Validate manual override functionality
- Test edge cases: midnight rollover, schedule conflicts, invalid times
- Verify integration with existing feeding and button services

### Task 8: Documentation and code review (AC: 1-8)
- Add Doxygen documentation for all public functions
- Create component documentation file with usage examples
- Document schedule data format and configuration procedures
- Ensure coding standards compliance across all scheduler code

## Definition of Done
- [ ] All acceptance criteria met and tested
- [ ] Multiple daily schedules can be created and managed
- [ ] Scheduled feeding triggers automatically with ±10 second accuracy
- [ ] Schedules persist across system reboots
- [ ] Manual feeding can override scheduled operations
- [ ] Code follows defined coding standards
- [ ] Component documentation completed
- [ ] Integration testing successful with existing services

## Notes
This story begins Epic 2 by introducing time-based automation, building on the hardware control foundation from Epic 1. It establishes the core scheduling infrastructure that will be enhanced with web configuration interfaces and advanced features in subsequent stories.

## Dev Agent Record
*This section will be populated by the Dev Agent during implementation*

### Implementation Notes
- 

### Challenges Encountered
- 

### Completion Notes
- 

### Debug Log References
- 